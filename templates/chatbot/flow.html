{% extends "base.html" %}

{% block title %}{{ flow.name }} - BankU{% endblock %}

{% block head %}
<meta name="csrf-token" content="{{ csrf_token() }}">
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-md-8 col-lg-6">
            <div class="card border-0 shadow-sm">
                <div class="card-header bg-white border-bottom text-center">
                    <div class="d-flex justify-content-between align-items-center">
                        <div></div>
                        <div>
                            <h1 class="h3 mb-0">
                                <i class="fas fa-robot me-2 text-primary"></i>{{ flow.name }}
                            </h1>
                            {% if flow.description %}
                            <p class="text-muted mb-0 mt-2">{{ flow.description }}</p>
                            {% endif %}
                        </div>
                        <div>
                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="refreshQuestions()" title="Refresh Questions">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="card-body">
                    <!-- Progress Bar -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <small class="text-muted">Progress</small>
                            <small class="text-muted" id="progressText">0 of 0</small>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar" role="progressbar" style="width: 0%" id="progressBar"></div>
                        </div>
                    </div>
                    
                    <!-- Chatbot Form -->
                    <form id="chatbotForm">
                        <div id="questionsContainer">
                            <!-- Questions will be loaded here -->
                        </div>
                        
                        <!-- Navigation Buttons -->
                        <div class="d-flex justify-content-between mt-4">
                            <button type="button" class="btn btn-outline-secondary" id="prevBtn" style="display: none;">
                                <i class="fas fa-arrow-left me-2"></i>Previous
                            </button>
                            <div class="ms-auto">
                                <button type="button" class="btn btn-outline-primary me-2" id="saveBtn" style="display: none;">
                                    <i class="fas fa-save me-2"></i>Save Progress
                                </button>
                                <button type="button" class="btn btn-primary" id="nextBtn">
                                    Next <i class="fas fa-arrow-right ms-2"></i>
                                </button>
                                <button type="submit" class="btn btn-success" id="submitBtn" style="display: none;">
                                    <i class="fas fa-check me-2"></i>Complete
                                </button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center" 
     style="background-color: rgba(0,0,0,0.5); z-index: 9999; cursor: pointer;" 
     onclick="hideLoading()" title="Click to hide loading">
    <div class="text-center text-white">
        <i class="fas fa-spinner fa-spin fa-2x mb-3"></i>
        <p>Loading...</p>
        <small class="text-muted">Click anywhere to hide if stuck</small>
    </div>
</div>

<style>
.step-block {
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    background-color: #f8f9fa;
}

/* Media Upload Styling */
.media-upload-container {
    margin-top: 15px;
}

.media-upload-box {
    transition: all 0.3s ease;
}

.media-upload-box .card {
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: box-shadow 0.3s ease;
}

.media-upload-box .card:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.media-upload-box .card-header {
    border-bottom: 1px solid rgba(255,255,255,0.2);
}

.media-preview-area {
    min-height: 50px;
    border: 2px dashed #dee2e6;
    border-radius: 4px;
    padding: 10px;
    background: #f8f9fa;
    margin-top: 10px;
}

.media-preview-area:empty::before {
    content: "No files uploaded yet";
    color: #6c757d;
    font-style: italic;
}

.media-type-checkbox:checked + label {
    font-weight: bold;
}

.media-type-checkbox:not(:checked) + label {
    opacity: 0.6;
}

.step-header {
    border-bottom: 2px solid #007bff;
    padding-bottom: 1rem;
    margin-bottom: 1.5rem;
}

.step-title {
    color: #007bff;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.step-questions .question-item {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background-color: white;
    border-radius: 6px;
    border: 1px solid #dee2e6;
}

.step-questions .question-item:last-child {
    margin-bottom: 0;
}

.radio-group .form-check,
.checkbox-group .form-check {
    margin-bottom: 0.5rem;
}

.radio-group .form-check:last-child,
.checkbox-group .form-check:last-child {
    margin-bottom: 0;
}

.tags-input-container .tags-input {
    border-radius: 6px;
    border: 2px solid #e9ecef;
    transition: border-color 0.2s;
}

.tags-input-container .tags-input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.tags-preview .badge {
    font-size: 0.875rem;
    padding: 0.5rem 0.75rem;
    border-radius: 20px;
    background-color: #007bff !important;
    color: white;
    border: none;
    display: inline-block;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
}

.tags-preview .badge:hover {
    background-color: #0056b3 !important;
    transform: translateY(-1px);
    transition: all 0.2s;
}

.url-input-container .url-input {
    border-radius: 6px;
    border: 2px solid #e9ecef;
    transition: border-color 0.2s;
}

.url-input-container .url-input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.url-input-container .url-input.is-valid {
    border-color: #28a745;
}

.url-input-container .url-input.is-invalid {
    border-color: #dc3545;
}

.url-validation {
    min-height: 20px;
}

.url-validation .text-success,
.url-validation .text-danger {
    font-size: 0.875rem;
}
</style>

<!-- Pass flow ID to JavaScript -->
<div id="flow-data" data-flow-id="{{ flow.id }}" style="display: none;"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const flowId = document.getElementById('flow-data').dataset.flowId;
    const questionsContainer = document.getElementById('questionsContainer');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const saveBtn = document.getElementById('saveBtn');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const loadingOverlay = document.getElementById('loadingOverlay');
    
    let steps = [];
    let questions = [];
    let currentStepIndex = 0;
    let currentQuestionIndex = 0;
    let responses = {};
    
    // Debug function to test branching logic
    window.debugBranchingLogic = function() {
        console.log('üîç DEBUGGING BRANCHING LOGIC');
        console.log('üîç Current responses:', responses);
        console.log('üîç Current step:', currentStepIndex);
        console.log('üîç Current question:', currentQuestionIndex);
        
        // Check all questions and their branching rules
        steps.forEach((step, stepIndex) => {
            console.log(`üîç Step ${stepIndex + 1}: ${step.name}`);
            step.questions.forEach((question, qIndex) => {
                console.log(`üîç Question ${qIndex + 1}: ${question.question_text}`);
                if (question.branching_logic && question.branching_logic.enabled) {
                    console.log(`üîç Has branching logic:`, question.branching_logic);
                    question.branching_logic.rules.forEach((rule, ruleIndex) => {
                        console.log(`üîç Rule ${ruleIndex + 1}: condition="${rule.condition}", action="${rule.action}", target="${rule.target}"`);
                    });
                } else {
                    console.log(`üîç No branching logic`);
                }
            });
        });
    };
    
    // Load questions
    // Test if basic elements exist
    if (!questionsContainer) {
        console.error('Questions container not found!');
        return;
    }
    
    if (!loadingOverlay) {
        console.error('Loading overlay not found!');
        return;
    }
    
    // Initially hide the loading overlay
    hideLoading();
    
    loadQuestions();
    
    function showLoading() {
        if (loadingOverlay) {
            loadingOverlay.style.setProperty('display', 'flex', 'important');
        }
    }
    
    function hideLoading() {
        if (loadingOverlay) {
            loadingOverlay.style.setProperty('display', 'none', 'important');
        }
    }
    
    function refreshQuestions() {
        console.log('Manually refreshing questions...');
        loadQuestions();
    }
    
    function loadQuestions() {
        showLoading();
        
        // Safety timeout to ensure loading is hidden even if something goes wrong
        const safetyTimeout = setTimeout(() => {
            console.warn('Loading timeout reached, forcing hide loading');
            hideLoading();
        }, 10000); // 10 seconds timeout
        
        // Add cache-busting and force refresh
        const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
        console.log('Loading questions with cache buster:', cacheBuster);
        
        fetch(`/chatbot/${flowId}/questions?${cacheBuster}`)
            .then(response => response.json())
            .then(data => {
                try {
                if (data.success) {
                    steps = data.steps || [];
                    questions = data.questions || [];
                    
                    // Debug: Check branching logic in questions
                    console.log('Loaded questions with branching logic:');
                    questions.forEach(q => {
                        console.log(`Question ${q.id}: ${q.question_text}`);
                        console.log(`Branching logic:`, q.branching_logic);
                    });
                    
                    if (steps.length > 0) {
                        // Use step blocks system
                        renderCurrentStep();
                    } else if (questions.length > 0) {
                        // Fallback to old question system
                        renderCurrentQuestion();
                    } else {
                        alert('No questions found in this chatbot flow.');
                        return;
                    }
                    
                    updateProgress();
                } else {
                    alert('Error loading questions: ' + data.error);
                    }
                } catch (error) {
                    console.error('Error in loadQuestions processing:', error);
                    alert('An error occurred while processing questions.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while loading questions.');
            })
            .finally(() => {
                // Clear the safety timeout
                clearTimeout(safetyTimeout);
                
                // Always hide loading, even if there was an error
                setTimeout(() => {
                    hideLoading();
                }, 100);
            });
    }
    
    function renderCurrentStep() {
        try {
        if (currentStepIndex >= steps.length) {
            return;
        }
        
        const step = steps[currentStepIndex];
        
        if (!step || !step.questions || step.questions.length === 0) {
            alert('This step has no questions.');
            return;
        }
        
        const stepHtml = createStepHtml(step);
        questionsContainer.innerHTML = stepHtml;
        
        // Set existing responses if available
        step.questions.forEach(question => {
            if (responses[question.id]) {
                setQuestionValue(question, responses[question.id]);
            }
        });
        
        // Setup cascading dropdowns
        setupCascadingDropdowns(step);
        
        // Setup tags input
        setupTagsInput(step);
        
        // Setup URL validation
        setupUrlValidation(step);
        
        // Setup conditional branching
        setupConditionalBranching(step);
            
            // Re-evaluate question visibility after rendering
            reEvaluateQuestionVisibility();
        
        updateNavigation();
        } catch (error) {
            console.error('Error in renderCurrentStep:', error);
            alert('An error occurred while rendering the current step.');
        }
    }
    
    function renderCurrentQuestion() {
        if (currentQuestionIndex >= questions.length) {
            return;
        }
        
        const question = questions[currentQuestionIndex];
        const questionHtml = createQuestionHtml(question);
        questionsContainer.innerHTML = questionHtml;
        
        // Set existing response if available
        if (responses[question.id]) {
            setQuestionValue(question, responses[question.id]);
        }
        
        updateNavigation();
    }
    
    function createStepHtml(step) {
        let html = `
            <div class="step-block">
                <div class="step-header mb-4">
                    <div class="d-flex justify-content-between align-items-center">
                        <h4 class="step-title mb-0">${step.name || 'Untitled Step'}</h4>
                        <span class="badge ${step.is_required ? 'bg-danger' : 'bg-success'} ms-2" style="font-size: 0.75rem;">
                            ${step.is_required ? 'Required' : 'Optional'}
                        </span>
                    </div>
                    ${step.description ? `<p class="text-muted mt-2">${step.description}</p>` : ''}
                </div>
                <div class="step-questions">
        `;
        
        if (step.questions && step.questions.length > 0) {
            step.questions.forEach(question => {
                // Always render the question HTML
                const questionHtml = createQuestionHtml(question);
                const shouldShow = shouldShowQuestion(question);
                
                // Add the question HTML (which already has data-question-id)
                html += questionHtml;
                
                console.log(`[RENDER] Rendered question ${question.id} (should show: ${shouldShow})`);
            });
        } else {
            html += '<p class="text-muted">No questions in this step.</p>';
        }
        
        html += `
                </div>
            </div>
        `;
        
        return html;
    }
    
    function createQuestionHtml(question) {
        // Determine initial visibility based on shouldShowQuestion
        const shouldShow = shouldShowQuestion(question);
        const displayStyle = shouldShow ? 'block' : 'none';
        
        let html = `
            <div class="question-item" data-question-id="${question.id}" style="display: ${displayStyle};">
                <div class="mb-3">
                    <label class="form-label h5">
                        ${question.question_text}
                        ${question.is_required ? '<span class="text-danger ms-1">*</span>' : ''}
                    </label>
                    ${question.help_text ? `<small class="text-muted d-block">${question.help_text}</small>` : ''}
                </div>
        `;
        
        switch (question.question_type) {
            case 'location':
                html += `
                    <div class="location-input-container">
                        <div class="mb-2">
                            <label class="form-label">Location Link</label>
                            <input type="url" 
                                   class="form-control location-link-input" 
                                   name="question_${question.id}_link"
                                   placeholder="https://maps.google.com/?q=...">
                            <small class="text-muted d-block mt-1">Paste a link from Google Maps, Apple Maps, etc.</small>
                        </div>
                        <div class="d-flex gap-2 align-items-center mb-2">
                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="useMyLocation(${question.id})">
                                <i class="fas fa-location-arrow me-1"></i> Use my location
                            </button>
                            <span class="small text-muted" id="location-status-${question.id}"></span>
                        </div>
                        <input type="hidden" name="question_${question.id}_lat">
                        <input type="hidden" name="question_${question.id}_lng">
                    </div>
                `;
                break;
            case 'text':
            case 'email':
            case 'phone':
            case 'number':
                html += `
                    <input type="${question.question_type}" 
                           class="form-control" 
                           name="question_${question.id}"
                           placeholder="${question.placeholder || ''}"
                           ${question.is_required ? 'required' : ''}>
                `;
                break;
                
            case 'date':
                html += `
                    <input type="date" 
                           class="form-control" 
                           name="question_${question.id}"
                           ${question.is_required ? 'required' : ''}>
                `;
                break;
                
            case 'url':
                html += `
                    <div class="url-input-container">
                        <input type="url" 
                               class="form-control url-input" 
                               name="question_${question.id}"
                               placeholder="${question.placeholder || 'example.com'}"
                               ${question.is_required ? 'required' : ''}>
                        <small class="text-muted d-block mt-1">
                            <i class="fas fa-globe me-1"></i>
                            Enter a website URL (e.g., example.com or https://example.com)
                        </small>
                        <div class="url-validation mt-2" id="url-validation-${question.id}">
                            <!-- URL validation feedback will appear here -->
                        </div>
                    </div>
                `;
                break;
                
            case 'textarea':
                html += `
                    <textarea class="form-control" 
                              name="question_${question.id}"
                              rows="4"
                              placeholder="${question.placeholder || 'Enter your response...'}"
                              ${question.is_required ? 'required' : ''}></textarea>
                    <small class="text-muted d-block mt-1">
                        <i class="fas fa-info-circle me-1"></i>
                        Provide a detailed response
                    </small>
                `;
                break;
                
            case 'select':
                html += `
                    <select class="form-select" 
                            name="question_${question.id}"
                            ${question.is_required ? 'required' : ''}>
                        <option value="">Choose an option...</option>
                        ${question.options ? question.options.map(option => 
                            `<option value="${option}">${option}</option>`
                        ).join('') : ''}
                    </select>
                `;
                break;
                
            case 'dropdown':
                html += `
                    <select class="form-select" 
                            name="question_${question.id}"
                            ${question.is_required ? 'required' : ''}>
                        <option value="">Choose an option...</option>
                        ${question.options ? question.options.map(option => 
                            `<option value="${option}">${option}</option>`
                        ).join('') : ''}
                    </select>
                `;
                break;
                
            case 'radio':
                html += '<div class="radio-group">';
                if (question.options) {
                    question.options.forEach(option => {
                        html += `
                            <div class="form-check">
                                <input class="form-check-input" 
                                       type="radio" 
                                       name="question_${question.id}" 
                                       value="${option}"
                                       id="radio_${question.id}_${option.replace(/\s+/g, '_')}"
                                       ${question.is_required ? 'required' : ''}>
                                <label class="form-check-label" for="radio_${question.id}_${option.replace(/\s+/g, '_')}">
                                    ${option}
                                </label>
                            </div>
                        `;
                    });
                }
                html += '</div>';
                break;
                
            case 'checkbox':
                html += '<div class="checkbox-group">';
                if (question.options) {
                    question.options.forEach(option => {
                        html += `
                            <div class="form-check">
                                <input class="form-check-input" 
                                       type="checkbox" 
                                       name="question_${question.id}[]" 
                                       value="${option}"
                                       id="checkbox_${question.id}_${option.replace(/\s+/g, '_')}">
                                <label class="form-check-label" for="checkbox_${question.id}_${option.replace(/\s+/g, '_')}">
                                    ${option}
                                </label>
                            </div>
                        `;
                    });
                }
                html += '</div>';
                break;
                
                
            case 'cascading_dropdown':
                // Handle cascading dropdown
                const cascadingConfig = question.cascading_config || {};
                const primaryLabel = cascadingConfig.primary_label || 'Select Category';
                const secondaryLabel = cascadingConfig.secondary_label || 'Select Subcategory';
                const cascadingCategories = cascadingConfig.categories || [];
                
                html += `
                    <div class="cascading-dropdown-container">
                        <div class="mb-3">
                            <label class="form-label">${primaryLabel}</label>
                            <select class="form-select" name="question_${question.id}_category" id="category_${question.id}">
                                <option value="">Choose a category...</option>
                                ${cascadingCategories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">${secondaryLabel}</label>
                            <select class="form-select" name="question_${question.id}_subcategory" id="subcategory_${question.id}" disabled>
                                <option value="">Choose a subcategory...</option>
                            </select>
                        </div>
                    </div>
                `;
                break;
                
            case 'tags':
                // Handle tags input (comma-separated)
                html += `
                    <div class="tags-input-container">
                        <input type="text" 
                               class="form-control tags-input" 
                               name="question_${question.id}"
                               placeholder="${question.placeholder || 'Enter tags separated by commas (e.g., technology, business, marketing)'}"
                               ${question.is_required ? 'required' : ''}>
                        <small class="text-muted d-block mt-1">
                            <i class="fas fa-info-circle me-1"></i>
                            Separate multiple tags with commas. Example: technology, business, marketing
                        </small>
                        <div class="tags-preview mt-2" id="tags-preview-${question.id}">
                            <!-- Tags will be displayed here as user types -->
                        </div>
                    </div>
                `;
                break;
                
            case 'number_unit':
                // Handle number + unit input
                const numberLabel = question.number_unit_config?.number_label || 'Amount';
                const unitLabel = question.number_unit_config?.unit_label || 'Currency';
                const unitOptions = question.number_unit_config?.unit_options || ['USD', 'EUR', 'GBP'];
                
                html += `
                    <div class="number-unit-container">
                        <div class="row">
                            <div class="col-md-6">
                                <label class="form-label">${numberLabel}</label>
                                <input type="number" 
                                       class="form-control number-input" 
                                       name="question_${question.id}_number"
                                       placeholder="Enter amount"
                                       ${question.is_required ? 'required' : ''}>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label">${unitLabel}</label>
                                <select class="form-select unit-select" 
                                        name="question_${question.id}_unit"
                                        ${question.is_required ? 'required' : ''}>
                                    <option value="">Select ${unitLabel.toLowerCase()}</option>
                                    ${unitOptions.map(option => `<option value="${option}">${option}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <small class="text-muted d-block mt-1">
                            <i class="fas fa-info-circle me-1"></i>
                            Enter a number and select the appropriate unit
                        </small>
                    </div>
                `;
                break;
                
            case 'images':
                // Handle images upload
                const imagesConfig = question.media_upload_config || {};
                const imagesUploadLabel = imagesConfig.upload_label || 'Upload Images';
                const imagesUrlLabel = imagesConfig.url_label || 'Or provide image URLs';
                const imagesMaxFiles = imagesConfig.max_files || 5;
                const imagesExtensions = imagesConfig.extensions || ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'];
                const imagesMaxSize = imagesConfig.max_size_formatted || '10 MB';
                const imagesEnableUpload = imagesConfig.enable_upload !== false; // Default to true
                const imagesEnableUrl = imagesConfig.enable_url !== false; // Default to true
                
                html += `
                    <div class="media-upload-container">
                        <div class="card border-primary">
                            <div class="card-header bg-primary text-white">
                                <h6 class="mb-0">
                                    <i class="fas fa-image me-2"></i>
                                    Images Upload
                                    <span class="badge bg-light text-dark ms-2">Max ${imagesMaxFiles} images</span>
                                </h6>
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">Upload image files or provide image URLs</p>
                                
                                <!-- File Upload -->
                                ${imagesEnableUpload ? `
                                <div class="mb-3">
                                    <label class="form-label">${imagesUploadLabel}</label>
                                    <input type="file" 
                                           class="form-control media-file-input" 
                                           name="question_${question.id}_files"
                                           multiple
                                           accept="${imagesExtensions.map(ext => `.${ext}`).join(',')}"
                                           data-question-id="${question.id}"
                                           data-file-type="images">
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        Max size: ${imagesMaxSize}. Allowed: ${imagesExtensions.join(', ')}
                                    </small>
                                </div>
                                ` : ''}
                                
                                <!-- URL Input -->
                                ${imagesEnableUrl ? `
                                <div class="mb-3">
                                    <label class="form-label">${imagesUrlLabel}</label>
                                    <textarea class="form-control media-url-input" 
                                              name="question_${question.id}_urls"
                                              rows="2"
                                              data-question-id="${question.id}"
                                              data-file-type="images"
                                              placeholder="Enter image URLs separated by new lines&#10;https://example.com/image1.jpg"></textarea>
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        One URL per line for external image files
                                    </small>
                                </div>
                                ` : ''}
                                
                                <!-- Preview Area -->
                                <div class="media-preview-area" id="media-preview-${question.id}">
                                    <!-- Uploaded files and URLs will be previewed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                break;
                
            case 'videos':
                // Handle videos upload
                const videosConfig = question.media_upload_config || {};
                const videosUploadLabel = videosConfig.upload_label || 'Upload Videos';
                const videosUrlLabel = videosConfig.url_label || 'Or provide video URLs';
                const videosMaxFiles = videosConfig.max_files || 3;
                const videosExtensions = videosConfig.extensions || ['mp4', 'avi', 'mov', 'webm'];
                const videosMaxSize = videosConfig.max_size_formatted || '100 MB';
                const videosEnableUpload = videosConfig.enable_upload !== false; // Default to true
                const videosEnableUrl = videosConfig.enable_url !== false; // Default to true
                
                html += `
                    <div class="media-upload-container">
                        <div class="card border-success">
                            <div class="card-header bg-success text-white">
                                <h6 class="mb-0">
                                    <i class="fas fa-video me-2"></i>
                                    Videos Upload
                                    <span class="badge bg-light text-dark ms-2">Max ${videosMaxFiles} videos</span>
                                </h6>
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">Upload video files or provide video URLs</p>
                                
                                <!-- File Upload -->
                                ${videosEnableUpload ? `
                        <div class="mb-3">
                                    <label class="form-label">${videosUploadLabel}</label>
                                    <input type="file" 
                                           class="form-control media-file-input" 
                                           name="question_${question.id}_files"
                                           multiple
                                           accept="${videosExtensions.map(ext => `.${ext}`).join(',')}"
                                           data-question-id="${question.id}"
                                           data-file-type="videos">
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        Max size: ${videosMaxSize}. Allowed: ${videosExtensions.join(', ')}
                                    </small>
                                    </div>
                                ` : ''}
                                
                                <!-- URL Input -->
                                ${videosEnableUrl ? `
                                <div class="mb-3">
                                    <label class="form-label">${videosUrlLabel}</label>
                                    <textarea class="form-control media-url-input" 
                                              name="question_${question.id}_urls"
                                              rows="2"
                                              data-question-id="${question.id}"
                                              data-file-type="videos"
                                              placeholder="Enter video URLs separated by new lines&#10;https://example.com/video1.mp4"></textarea>
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        One URL per line for external video files
                                    </small>
                                </div>
                                ` : ''}
                                
                                <!-- Preview Area -->
                                <div class="media-preview-area" id="media-preview-${question.id}">
                                    <!-- Uploaded files and URLs will be previewed here -->
                            </div>
                        </div>
                        </div>
                    </div>
                `;
                break;
                
            case 'audio':
                // Handle audio upload
                const audioConfig = question.media_upload_config || {};
                const audioUploadLabel = audioConfig.upload_label || 'Upload Audio';
                const audioUrlLabel = audioConfig.url_label || 'Or provide audio URLs';
                const audioMaxFiles = audioConfig.max_files || 5;
                const audioExtensions = audioConfig.extensions || ['mp3', 'wav', 'flac', 'aac', 'ogg'];
                const audioMaxSize = audioConfig.max_size_formatted || '50 MB';
                const audioEnableUpload = audioConfig.enable_upload !== false; // Default to true
                const audioEnableUrl = audioConfig.enable_url !== false; // Default to true
                
                html += `
                    <div class="media-upload-container">
                        <div class="card border-info">
                            <div class="card-header bg-info text-white">
                                        <h6 class="mb-0">
                                    <i class="fas fa-music me-2"></i>
                                    Audio Upload
                                    <span class="badge bg-light text-dark ms-2">Max ${audioMaxFiles} files</span>
                                        </h6>
                                    </div>
                                    <div class="card-body">
                                <p class="text-muted small mb-3">Upload audio files or provide audio URLs</p>
                                
                                <!-- File Upload -->
                                ${audioEnableUpload ? `
                                        <div class="mb-3">
                                    <label class="form-label">${audioUploadLabel}</label>
                                            <input type="file" 
                                                   class="form-control media-file-input" 
                                           name="question_${question.id}_files"
                                                   multiple
                                           accept="${audioExtensions.map(ext => `.${ext}`).join(',')}"
                                           data-question-id="${question.id}"
                                           data-file-type="audio">
                                            <small class="text-muted d-block mt-1">
                                                <i class="fas fa-info-circle me-1"></i>
                                        Max size: ${audioMaxSize}. Allowed: ${audioExtensions.join(', ')}
                                            </small>
                                        </div>
                                ` : ''}
                                        
                                <!-- URL Input -->
                                ${audioEnableUrl ? `
                                        <div class="mb-3">
                                    <label class="form-label">${audioUrlLabel}</label>
                                            <textarea class="form-control media-url-input" 
                                              name="question_${question.id}_urls"
                                                      rows="2"
                                              data-question-id="${question.id}"
                                              data-file-type="audio"
                                              placeholder="Enter audio URLs separated by new lines&#10;https://example.com/audio1.mp3"></textarea>
                                            <small class="text-muted d-block mt-1">
                                                <i class="fas fa-info-circle me-1"></i>
                                        One URL per line for external audio files
                                            </small>
                                        </div>
                                ` : ''}
                                        
                                <!-- Preview Area -->
                                <div class="media-preview-area" id="media-preview-${question.id}">
                                            <!-- Uploaded files and URLs will be previewed here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            `;
                break;
                
            case 'files_documents':
                // Handle files & documents upload
                const filesConfig = question.media_upload_config || {};
                const filesUploadLabel = filesConfig.upload_label || 'Upload Files';
                const filesUrlLabel = filesConfig.url_label || 'Or provide file URLs';
                const filesMaxFiles = filesConfig.max_files || 5;
                const filesExtensions = filesConfig.extensions || ['pdf', 'doc', 'docx', 'txt'];
                const filesMaxSize = filesConfig.max_size_formatted || '25 MB';
                const filesEnableUpload = filesConfig.enable_upload !== false; // Default to true
                const filesEnableUrl = filesConfig.enable_url !== false; // Default to true
                
                html += `
                    <div class="media-upload-container">
                        <div class="card border-warning">
                            <div class="card-header bg-warning text-dark">
                                <h6 class="mb-0">
                                    <i class="fas fa-file-alt me-2"></i>
                                    Files & Documents Upload
                                    <span class="badge bg-light text-dark ms-2">Max ${filesMaxFiles} files</span>
                                </h6>
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">Upload documents, PDFs, and other files or provide URLs</p>
                                
                                <!-- File Upload -->
                                ${filesEnableUpload ? `
                                <div class="mb-3">
                                    <label class="form-label">${filesUploadLabel}</label>
                                    <input type="file" 
                                           class="form-control media-file-input" 
                                           name="question_${question.id}_files"
                                           multiple
                                           accept="${filesExtensions.map(ext => `.${ext}`).join(',')}"
                                           data-question-id="${question.id}"
                                           data-file-type="files_documents">
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        Max size: ${filesMaxSize}. Allowed: ${filesExtensions.join(', ')}
                                    </small>
                                </div>
                                ` : ''}
                                
                                <!-- URL Input -->
                                ${filesEnableUrl ? `
                                <div class="mb-3">
                                    <label class="form-label">${filesUrlLabel}</label>
                                    <textarea class="form-control media-url-input" 
                                              name="question_${question.id}_urls"
                                              rows="2"
                                              data-question-id="${question.id}"
                                              data-file-type="files_documents"
                                              placeholder="Enter file URLs separated by new lines&#10;https://example.com/document1.pdf"></textarea>
                                    <small class="text-muted d-block mt-1">
                                        <i class="fas fa-info-circle me-1"></i>
                                        One URL per line for external files
                                    </small>
                                </div>
                                ` : ''}
                                
                                <!-- Preview Area -->
                                <div class="media-preview-area" id="media-preview-${question.id}">
                                    <!-- Uploaded files and URLs will be previewed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                break;
        }
        
        html += '</div>';
        return html;
    }
    
    function setQuestionValue(question, value) {
        const questionElement = questionsContainer.querySelector(`[data-question-id="${question.id}"]`);
        if (!questionElement) return;
        
        if (question.question_type === 'location') {
            if (value && typeof value === 'object') {
                const linkInput = questionElement.querySelector(`[name="question_${question.id}_link"]`);
                const latInput = questionElement.querySelector(`[name="question_${question.id}_lat"]`);
                const lngInput = questionElement.querySelector(`[name="question_${question.id}_lng"]`);
                if (linkInput && value.link) linkInput.value = value.link;
                if (latInput && value.lat != null) latInput.value = value.lat;
                if (lngInput && value.lng != null) lngInput.value = value.lng;
            }
            return;
        }

        if (question.question_type === 'cascading_dropdown') {
            const categorySelect = questionElement.querySelector(`#category_${question.id}`);
            const subcategorySelect = questionElement.querySelector(`#subcategory_${question.id}`);
            
            if (categorySelect && subcategorySelect && value && value.category && value.subcategory) {
                categorySelect.value = value.category;
                // Trigger change event to populate subcategories
                categorySelect.dispatchEvent(new Event('change'));
                // Set subcategory after a short delay to allow subcategories to load
                setTimeout(() => {
                    subcategorySelect.value = value.subcategory;
                }, 100);
            }
            return;
        }
        
        if (question.question_type === 'tags') {
            const input = questionElement.querySelector(`[name="question_${question.id}"]`);
            if (input && value) {
                // If value is an array, join with commas
                if (Array.isArray(value)) {
                    input.value = value.join(', ');
                } else {
                    input.value = value;
                }
                // Update tags preview
                updateTagsPreview(question.id, input.value);
            }
            return;
        }
        
        if (question.question_type === 'url') {
            const input = questionElement.querySelector(`[name="question_${question.id}"]`);
            if (input && value) {
                input.value = value;
                // Update URL validation
                validateUrl(question.id, value);
            }
            return;
        }
        
        if (question.question_type === 'number_unit') {
            const numberInput = questionElement.querySelector(`[name="question_${question.id}_number"]`);
            const unitSelect = questionElement.querySelector(`[name="question_${question.id}_unit"]`);
            
            if (numberInput && unitSelect && value) {
                if (typeof value === 'object' && value.number !== undefined && value.unit !== undefined) {
                    numberInput.value = value.number;
                    unitSelect.value = value.unit;
                } else if (typeof value === 'string') {
                    // Try to parse "3 USD" format
                    const match = value.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
                    if (match) {
                        numberInput.value = match[1];
                        unitSelect.value = match[2];
                    }
                }
            }
            return;
        }
        
        if (['images', 'videos', 'audio', 'files_documents'].includes(question.question_type)) {
            if (value && typeof value === 'object') {
                const fileInput = questionElement.querySelector(`[name="question_${question.id}_files"]`);
                const urlInput = questionElement.querySelector(`[name="question_${question.id}_urls"]`);
                        
                        if (fileInput && urlInput) {
                            // Note: Can't programmatically set file input for security reasons
                            // Files would need to be handled differently
                            
                    if (value.urls && Array.isArray(value.urls)) {
                        urlInput.value = value.urls.join('\n');
                            }
                        }
            }
            return;
        }
        
        const input = questionElement.querySelector(`[name="question_${question.id}"]`);
        if (!input) return;
        
        if (question.question_type === 'checkbox') {
            // Handle checkbox values (array)
            if (Array.isArray(value)) {
                value.forEach(val => {
                    const checkbox = questionElement.querySelector(`input[value="${val}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
        } else if (question.question_type === 'radio') {
            // Handle radio values
            const radio = questionElement.querySelector(`input[value="${value}"]`);
            if (radio) radio.checked = true;
        } else if (question.question_type === 'select' || question.question_type === 'dropdown') {
            // Handle select/dropdown elements
            const select = questionElement.querySelector(`select[name="question_${question.id}"]`);
            if (select) select.value = value;
        } else {
            // Handle other input types
            input.value = value;
        }
    }
    
    function getCurrentResponse() {
        const question = questions[currentQuestionIndex];
        const questionElement = questionsContainer.querySelector(`[data-question-id="${question.id}"]`);
        if (!questionElement) return null;
        
        const input = questionElement.querySelector(`[name="question_${question.id}"]`);
        if (!input) return null;
        
        if (question.question_type === 'checkbox') {
            const checkboxes = questionElement.querySelectorAll(`input[type="checkbox"]:checked`);
            return Array.from(checkboxes).map(cb => cb.value);
        } else if (question.question_type === 'radio') {
            const radio = questionElement.querySelector(`input[type="radio"]:checked`);
            return radio ? radio.value : null;
        } else {
            return input.value;
        }
    }
    
    function saveCurrentResponse() {
        console.log('[PROCESS] saveCurrentResponse called');
        console.log('Current step:', steps[currentStepIndex]);
        
        if (steps.length > 0) {
            // Step blocks system - save all questions in current step
            const step = steps[currentStepIndex];
            step.questions.forEach(question => {
                console.log(`Question ${question.id} (${question.question_type}):`, null);
                const response = getQuestionResponse(question);
                console.log(`Response for question ${question.id}:`, response);
                if (response !== null) {
                    responses[question.id] = response;
                    console.log(`[SUCCESS] Saved response for question ${question.id}:`, response);
                } else {
                    console.log(`[ERROR] No response for question ${question.id}`);
                }
            });
            console.log('All responses after save:', responses);
        } else {
            // Old question system
            const question = questions[currentQuestionIndex];
            const response = getCurrentResponse();
            if (response !== null) {
                responses[question.id] = response;
            }
        }
    }
    
    function getQuestionResponse(question) {
        const questionElement = questionsContainer.querySelector(`[data-question-id="${question.id}"]`);
        if (!questionElement) return null;
        
        if (question.question_type === 'location') {
            const linkInput = questionElement.querySelector(`[name="question_${question.id}_link"]`);
            const latInput = questionElement.querySelector(`[name="question_${question.id}_lat"]`);
            const lngInput = questionElement.querySelector(`[name="question_${question.id}_lng"]`);
            const link = linkInput ? linkInput.value.trim() : '';
            const lat = latInput ? latInput.value.trim() : '';
            const lng = lngInput ? lngInput.value.trim() : '';
            if (!link && !lat && !lng) return null;
            return {
                link: link || '',
                lat: lat ? parseFloat(lat) : null,
                lng: lng ? parseFloat(lng) : null
            };
        }

        if (question.question_type === 'cascading_dropdown') {
            const categorySelect = questionElement.querySelector(`#category_${question.id}`);
            const subcategorySelect = questionElement.querySelector(`#subcategory_${question.id}`);
            
            if (categorySelect && subcategorySelect) {
                const category = categorySelect.value;
                const subcategory = subcategorySelect.value;
                
                // Return response even if only category is selected
                    return {
                    category: category || '',
                    subcategory: subcategory || ''
                    };
            }
            return null;
        }
        
        if (question.question_type === 'tags') {
            const input = questionElement.querySelector(`[name="question_${question.id}"]`);
            if (!input || !input.value.trim()) return null;
            
            // Split by comma and clean up tags
            const tags = input.value.split(',')
                .map(tag => tag.trim())
                .filter(tag => tag.length > 0);
            
            return tags;
        }
        
        if (question.question_type === 'url') {
            const input = questionElement.querySelector(`[name="question_${question.id}"]`);
            if (!input || !input.value.trim()) return null;
            
            // Clean and validate URL
            let url = input.value.trim();
            
            // Add protocol if missing
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            
            return url;
        }
        
        if (question.question_type === 'number_unit') {
            const numberInput = questionElement.querySelector(`[name="question_${question.id}_number"]`);
            const unitSelect = questionElement.querySelector(`[name="question_${question.id}_unit"]`);
            
            if (numberInput && unitSelect) {
                const number = numberInput.value.trim();
                const unit = unitSelect.value;
                
                if (number && unit) {
                    return {
                        number: parseFloat(number),
                        unit: unit,
                        display: `${number} ${unit}`
                    };
                }
            }
            return null;
        }
        
        if (['images', 'videos', 'audio', 'files_documents'].includes(question.question_type)) {
            const fileInput = questionElement.querySelector(`[name="question_${question.id}_files"]`);
            const urlInput = questionElement.querySelector(`[name="question_${question.id}_urls"]`);
            const previewArea = document.getElementById(`media-preview-${question.id}`);
            
            // Check if at least one input exists (based on toggle settings)
            if (!fileInput && !urlInput) return null;
            
            const files = fileInput ? Array.from(fileInput.files) : [];
            const urls = urlInput ? urlInput.value.trim().split('\n').filter(url => url.trim()) : [];
                    
            if (files.length === 0 && urls.length === 0) {
                return null;
            }
                        
            const result = {
                files: [],
                urls: urls,
                file_type: question.question_type
            };
                        
            // Process uploaded files - collect from preview area if available
            if (previewArea) {
                const filePreviews = previewArea.querySelectorAll('.file-preview');
                filePreviews.forEach(preview => {
                    const fileName = preview.querySelector('.fw-bold').textContent.replace(' ‚úì', '').trim();
                    
                    // Try to get the full fileInfo from data attribute (new method)
                    const fileInfoAttr = preview.getAttribute('data-file-info');
                    if (fileInfoAttr) {
                        try {
                            const fileInfo = JSON.parse(fileInfoAttr);
                            // Find the original file info for metadata
                            const originalFile = files.find(f => f.name === fileName);
                            result.files.push({
                                name: fileName,
                                size: originalFile ? originalFile.size : fileInfo.size,
                                type: originalFile ? originalFile.type : fileInfo.mime_type,
                                lastModified: originalFile ? originalFile.lastModified : Date.now(),
                                saved_name: fileInfo.saved_name,
                                relative_path: fileInfo.relative_path // This is the key field!
                            });
                        } catch (e) {
                            console.error('Failed to parse file info:', e);
                        }
                    } else {
                        // Fallback to old method (scraping UI text)
                        const savedNameElement = preview.querySelector('small.text-success');
                        const savedName = savedNameElement ? savedNameElement.textContent.replace('Saved as: ', '') : fileName;
                        
                        // Find the original file info
                        const originalFile = files.find(f => f.name === fileName);
                        if (originalFile) {
                            result.files.push({
                                name: fileName,
                                size: originalFile.size,
                                type: originalFile.type,
                                lastModified: originalFile.lastModified,
                                saved_name: savedName
                            });
                        }
                    }
                });
            } else {
                // Fallback: process files directly
                files.forEach(file => {
                    result.files.push({
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified
                    });
                });
            }
            
            return result;
        }
        
        const input = questionElement.querySelector(`[name="question_${question.id}"]`);
        console.log(`[DEBUG] Looking for element: [name="question_${question.id}"]`);
        console.log(`[DEBUG] Found input element:`, input);
        console.log(`[DEBUG] Input type:`, input ? input.tagName : 'null');
        console.log(`[DEBUG] Input value:`, input ? input.value : 'null');
        
        if (!input) return null;
        
        if (question.question_type === 'checkbox') {
            const checkboxes = questionElement.querySelectorAll(`input[type="checkbox"]:checked`);
            return Array.from(checkboxes).map(cb => cb.value);
        } else if (question.question_type === 'radio') {
            const radio = questionElement.querySelector(`input[type="radio"]:checked`);
            return radio ? radio.value : null;
        } else if (question.question_type === 'select' || question.question_type === 'dropdown') {
            // Handle select/dropdown elements
            const select = questionElement.querySelector(`select[name="question_${question.id}"]`);
            console.log(`[DEBUG] Returning select.value for ${question.question_type}:`, select ? select.value : 'null');
            return select ? select.value : null;
        } else {
            console.log(`[DEBUG] Returning input.value for ${question.question_type}:`, input.value);
            return input.value;
        }
    }
    
    function setupCascadingDropdowns(step) {
        step.questions.forEach(question => {
            if (question.question_type === 'location') {
                // Attach geolocation handler
                window.useMyLocation = async function(questionId) {
                    const container = document.querySelector(`[data-question-id="${questionId}"]`);
                    const status = container ? container.querySelector(`#location-status-${questionId}`) : null;
                    const latInput = container ? container.querySelector(`[name="question_${questionId}_lat"]`) : null;
                    const lngInput = container ? container.querySelector(`[name="question_${questionId}_lng"]`) : null;
                    if (!navigator.geolocation) {
                        if (status) status.textContent = 'Geolocation not supported by this browser.';
                        return;
                    }
                    try {
                        if (status) status.textContent = 'Fetching device location...';
                        await new Promise((resolve, reject) => {
                            navigator.geolocation.getCurrentPosition(
                                pos => {
                                    const { latitude, longitude } = pos.coords;
                                    if (latInput) latInput.value = latitude;
                                    if (lngInput) lngInput.value = longitude;
                                    if (status) status.textContent = `Location set: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
                                    // Save immediately
                                    saveCurrentResponse();
                                    resolve();
                                },
                                err => {
                                    if (status) status.textContent = 'Unable to retrieve location.';
                                    resolve();
                                },
                                { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
                            );
                        });
                    } catch (e) {
                        if (status) status.textContent = 'Location error.';
                    }
                }
            }
            if (question.question_type === 'cascading_dropdown') {
                const categorySelect = document.getElementById(`category_${question.id}`);
                const subcategorySelect = document.getElementById(`subcategory_${question.id}`);
                
                if (categorySelect && subcategorySelect) {
                    const cascadingConfig = question.cascading_config || {};
                    const categories = cascadingConfig.categories || [];
                    
                    categorySelect.addEventListener('change', function() {
                        const selectedCategory = this.value;
                        subcategorySelect.innerHTML = '<option value="">Choose a subcategory...</option>';
                        
                        if (selectedCategory) {
                            const category = categories.find(cat => cat.name === selectedCategory);
                            if (category && category.subcategories) {
                                // Check if subcategories are grouped
                                if (Array.isArray(category.subcategories) && category.subcategories.length > 0 && category.subcategories[0].group !== undefined) {
                                    // Grouped subcategories
                                    category.subcategories.forEach(group => {
                                        if (group.group) {
                                            // Add group header (non-selectable)
                                            const groupOption = document.createElement('option');
                                            groupOption.value = '';
                                            groupOption.textContent = group.group;
                                            groupOption.disabled = true;
                                            groupOption.style.fontWeight = 'bold';
                                            groupOption.style.fontStyle = 'italic';
                                            groupOption.style.color = '#6c757d';
                                            subcategorySelect.appendChild(groupOption);
                                        }
                                        
                                        // Add items in this group
                                        if (group.items) {
                                            group.items.forEach(item => {
                                                const option = document.createElement('option');
                                                option.value = item;
                                                option.textContent = item;
                                                subcategorySelect.appendChild(option);
                                            });
                                        }
                                    });
                                    subcategorySelect.disabled = false;
                                } else if (category.subcategories.length > 0) {
                                    // Simple subcategories (backward compatibility)
                                    category.subcategories.forEach(subcat => {
                                        const option = document.createElement('option');
                                        option.value = subcat;
                                        option.textContent = subcat;
                                        subcategorySelect.appendChild(option);
                                    });
                                    subcategorySelect.disabled = false;
                                } else {
                                    // No subcategories available
                                    const noSubcatOption = document.createElement('option');
                                    noSubcatOption.value = '';
                                    noSubcatOption.textContent = 'No subcategories available';
                                    noSubcatOption.disabled = true;
                                    subcategorySelect.appendChild(noSubcatOption);
                                    subcategorySelect.disabled = true;
                                }
                            }
                        } else {
                            subcategorySelect.disabled = true;
                        }
                        
                        // Save the response when category changes
                        saveCurrentResponse();
                    });
                    
                    // Add change event listener for subcategory
                    subcategorySelect.addEventListener('change', function() {
                        // Save the response when subcategory changes
                        saveCurrentResponse();
                    });
                }
            }
        });
    }
    
    function setupTagsInput(step) {
        step.questions.forEach(question => {
            if (question.question_type === 'tags') {
                const input = document.querySelector(`[name="question_${question.id}"]`);
                if (input) {
                    input.addEventListener('input', function() {
                        updateTagsPreview(question.id, this.value);
                    });
                    
                    // Initial preview update
                    updateTagsPreview(question.id, input.value);
                }
            }
        });
    }
    
    function updateTagsPreview(questionId, value) {
        const preview = document.getElementById(`tags-preview-${questionId}`);
        if (!preview) return;
        
        if (!value.trim()) {
            preview.innerHTML = '';
            return;
        }
        
        // Split by comma and clean up tags
        const tags = value.split(',')
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0);
        
        if (tags.length === 0) {
            preview.innerHTML = '';
            return;
        }
        
        // Create tags display
        const tagsHtml = tags.map(tag => 
            `<span class="badge bg-primary me-1 mb-1">${tag}</span>`
        ).join('');
        
        preview.innerHTML = `
            <div class="d-flex flex-wrap">
                ${tagsHtml}
            </div>
        `;
    }
    
    function setupUrlValidation(step) {
        step.questions.forEach(question => {
            if (question.question_type === 'url') {
                const input = document.querySelector(`[name="question_${question.id}"]`);
                if (input) {
                    input.addEventListener('input', function() {
                        validateUrl(question.id, this.value);
                    });
                    
                    input.addEventListener('blur', function() {
                        validateUrl(question.id, this.value, true);
                    });
                    
                    // Initial validation
                    validateUrl(question.id, input.value);
                }
            }
        });
    }
    
    function validateUrl(questionId, value, showErrors = false) {
        const validation = document.getElementById(`url-validation-${questionId}`);
        const input = document.querySelector(`[name="question_${questionId}"]`);
        
        if (!validation || !input) return;
        
        if (!value.trim()) {
            validation.innerHTML = '';
            input.classList.remove('is-valid', 'is-invalid');
            return;
        }
        
        // Clean the URL first
        let cleanUrl = value.trim();
        
        // Auto-add https:// if missing
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
            cleanUrl = 'https://' + cleanUrl;
        }
        
        // Basic URL validation - more lenient
        const urlPattern = /^https?:\/\/.+\..+/i;
        const isValid = urlPattern.test(cleanUrl);
        
        if (isValid) {
            // Valid URL - show success and update input if needed
            if (input.value !== cleanUrl) {
                input.value = cleanUrl;
            }
            
            validation.innerHTML = `
                <div class="d-flex align-items-center text-success">
                    <i class="fas fa-check-circle me-2"></i>
                    <small>Valid URL format - ${cleanUrl}</small>
                </div>
            `;
            input.classList.remove('is-invalid');
            input.classList.add('is-valid');
        } else {
            // Invalid URL
            if (showErrors || value.length > 5) { // Only show errors after user starts typing
                validation.innerHTML = `
                    <div class="d-flex align-items-center text-danger">
                        <i class="fas fa-exclamation-circle me-2"></i>
                        <small>Please enter a valid URL (e.g., example.com or https://example.com)</small>
                    </div>
                `;
                input.classList.remove('is-valid');
                input.classList.add('is-invalid');
            } else {
                validation.innerHTML = '';
                input.classList.remove('is-valid', 'is-invalid');
            }
        }
    }
    
    function setupConditionalBranching(step) {
        step.questions.forEach(question => {
                const questionElement = questionsContainer.querySelector(`[data-question-id="${question.id}"]`);
                if (!questionElement) return;
                
                // Add event listeners to all input types
                const inputs = questionElement.querySelectorAll('input, select, textarea');
                inputs.forEach(input => {
                    input.addEventListener('change', function() {
                        // Clear validation messages when user starts fixing the field
                        clearValidationMessages();
                        
                        // CRITICAL: Save the response FIRST before checking visibility
                        console.log('[PROCESS] Input changed, saving response first...');
                        saveCurrentResponse();
                        
                        // Handle branching logic
                        if (question.branching_logic && question.branching_logic.enabled) {
                        checkBranchingLogic(question);
                        }
                        
                        // Re-evaluate visibility of all questions in current step
                        console.log('[PROCESS] Now re-evaluating question visibility...');
                        reEvaluateQuestionVisibility();
                    });
                    
                    // Also clear validation on input/typing
                    input.addEventListener('input', function() {
                        clearValidationMessages();
                    });
                    });
                });
    }
    
    function shouldShowQuestion(question) {
        // Check if any other question has rules that affect this question
        const currentStep = steps[currentStepIndex];
        if (!currentStep || !currentStep.questions) return true;
        
        console.log(`Checking visibility for question ${question.id}: ${question.question_text}`);
        console.log(`Question default_view: ${question.default_view}`);
        
        // Start with the question's default view setting
        let shouldShow = question.default_view === 'show';
        let hasRules = false;
        
        for (const otherQuestion of currentStep.questions) {
            if (otherQuestion.id === question.id) continue; // Skip self
            
            console.log(`Checking other question ${otherQuestion.id} for rules affecting question ${question.id}`);
            console.log(`Other question branching_logic:`, otherQuestion.branching_logic);
            
            if (otherQuestion.branching_logic && otherQuestion.branching_logic.enabled) {
                const rules = otherQuestion.branching_logic.rules || [];
                console.log(`Question ${otherQuestion.id} has ${rules.length} rules:`, rules);
                console.log(`Processing rules for question ${otherQuestion.id} affecting question ${question.id}`);
                console.log(`Rules array length:`, rules.length);
                console.log(`Rules array:`, rules);
                console.log(`About to enter rule processing loop...`);
                console.log(`Rules is array:`, Array.isArray(rules));
                console.log(`Rules length:`, rules.length);
                
                if (rules.length > 0) {
                    console.log(`First rule:`, rules[0]);
                    console.log(`First rule type:`, typeof rules[0]);
                }
                
                console.log(`Starting loop with i=0, rules.length=${rules.length}`);
                console.log(`Loop condition: i < rules.length, i=0, rules.length=${rules.length}`);
                console.log(`Loop condition result:`, 0 < rules.length);
                
                for (let i = 0; i < rules.length; i++) {
                    console.log(`Loop iteration ${i + 1}/${rules.length}`);
                    const rule = rules[i];
                    console.log(`Processing rule ${i + 1}/${rules.length}:`, rule);
                    console.log(`Rule exists:`, !!rule);
                    console.log(`Rule type:`, typeof rule);
                    console.log(`Rule: condition="${rule.condition}", action="${rule.action}", target="${rule.target}"`);
                    console.log(`Rule target_question_id:`, rule.target_question_id);
                    console.log(`Rule target_step_id:`, rule.target_step_id);
                    console.log(`Checking if rule target "${rule.target}" matches question ID "${question.id}"`);
                    console.log(`Rule target type:`, typeof rule.target);
                    console.log(`Question ID type:`, typeof question.id);
                    console.log(`Rule target === question.id.toString():`, rule.target === question.id.toString());
                    console.log(`Rule target === question.id:`, rule.target === question.id);
                    
                    // Check if this rule targets the current question
                    // Handle both direct question ID and specific_question_local cases
                    let ruleTargetsThisQuestion = false;
                    
                    if (rule.target === question.id.toString()) {
                        ruleTargetsThisQuestion = true;
                        console.log(`[SUCCESS] Direct target match: ${rule.target} === ${question.id}`);
                    } else if (rule.target === question.id) {
                        ruleTargetsThisQuestion = true;
                        console.log(`[SUCCESS] Direct target match (no toString): ${rule.target} === ${question.id}`);
                    } else if (rule.target === 'specific_question_local' && rule.target_question_id === question.id.toString()) {
                        ruleTargetsThisQuestion = true;
                        console.log(`[SUCCESS] Specific question local match: ${rule.target_question_id} === ${question.id}`);
                    } else {
                        // For new chatbots, also check if the rule target matches the question's order_index
                        const questionOrderIndex = question.order_index;
                        console.log(`[DEBUG] Comparing rule target "${rule.target}" (type: ${typeof rule.target}) with question order_index "${questionOrderIndex}" (type: ${typeof questionOrderIndex})`);
                        
                        if (rule.target === questionOrderIndex.toString() || rule.target === questionOrderIndex || 
                            parseInt(rule.target) === questionOrderIndex || rule.target == questionOrderIndex) {
                            ruleTargetsThisQuestion = true;
                            console.log(`[SUCCESS] Order index match: ${rule.target} === ${questionOrderIndex}`);
                        } else if (rule.target_order_index === questionOrderIndex.toString() || rule.target_order_index === questionOrderIndex ||
                                   parseInt(rule.target_order_index) === questionOrderIndex || rule.target_order_index == questionOrderIndex) {
                            ruleTargetsThisQuestion = true;
                            console.log(`[SUCCESS] Explicit order index match: ${rule.target_order_index} === ${questionOrderIndex}`);
                        } else {
                            // SMART ID MAPPING: Try to match old question IDs to current questions by text patterns
                            const ruleTargetStr = String(rule.target);
                            let shouldMatchByText = false;
                            
                            // Map old question IDs to their corresponding question text patterns
                            if ((ruleTargetStr === '247' || ruleTargetStr === '251' || ruleTargetStr === '271' || ruleTargetStr === '291' || ruleTargetStr === '323' || ruleTargetStr === '339') && 
                                question.question_text.toLowerCase().includes('suggest category')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Suggest Category" question ${question.id}`);
                            } else if ((ruleTargetStr === '252' || ruleTargetStr === '279' || ruleTargetStr === '280' || ruleTargetStr === '295' || ruleTargetStr === '327' || ruleTargetStr === '343') && 
                                       question.question_text.toLowerCase().includes('price amount')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Price Amount" question ${question.id}`);
                            } else if ((ruleTargetStr === '216' || ruleTargetStr === '228' || ruleTargetStr === '240' || ruleTargetStr === '296' || ruleTargetStr === '328' || ruleTargetStr === '344') && 
                                       question.question_text.toLowerCase().includes('price currency')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Price Currency" question ${question.id}`);
                            } else if ((ruleTargetStr === '267' || ruleTargetStr === '299' || ruleTargetStr === '315' || ruleTargetStr === '331' || ruleTargetStr === '347') && 
                                       question.question_text.toLowerCase().includes('brand')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Brand" question ${question.id}`);
                            } else if ((ruleTargetStr === '268' || ruleTargetStr === '300' || ruleTargetStr === '316' || ruleTargetStr === '332' || ruleTargetStr === '348') && 
                                       question.question_text.toLowerCase().includes('model')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Model" question ${question.id}`);
                            } else if ((ruleTargetStr === '269' || ruleTargetStr === '301' || ruleTargetStr === '317' || ruleTargetStr === '333' || ruleTargetStr === '349') && 
                                       question.question_text.toLowerCase().includes('condition')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Condition" question ${question.id}`);
                            } else if ((ruleTargetStr === '270' || ruleTargetStr === '302' || ruleTargetStr === '318' || ruleTargetStr === '334' || ruleTargetStr === '350') && 
                                       question.question_text.toLowerCase().includes('time of use')) {
                                shouldMatchByText = true;
                                console.log(`[SUCCESS] Smart mapping: old ID ${ruleTargetStr} maps to "Time of use" question ${question.id}`);
                            }
                            
                            if (shouldMatchByText) {
                                ruleTargetsThisQuestion = true;
                            } else {
                                console.log(`[ERROR] No match: target="${rule.target}", target_question_id="${rule.target_question_id}", question_id="${question.id}", order_index="${questionOrderIndex}", target_order_index="${rule.target_order_index}"`);
                            }
                        }
                    }
                    
                    if (ruleTargetsThisQuestion) {
                        hasRules = true; // This question is controlled by rules
                        
                        // Get the answer to the other question
                        const otherQuestionResponse = responses[otherQuestion.id];
                        let otherQuestionAnswer = '';
                        
                        if (otherQuestion.question_type === 'cascading_dropdown' && otherQuestionResponse) {
                            otherQuestionAnswer = otherQuestionResponse.category || '';
                        } else if (otherQuestionResponse) {
                            otherQuestionAnswer = otherQuestionResponse.toString();
                        }
                        
                        // Check if the condition matches
                        console.log(`[DEBUG] CONDITION CHECK: otherQuestionAnswer="${otherQuestionAnswer}" (type: ${typeof otherQuestionAnswer}) vs rule.condition="${rule.condition}" (type: ${typeof rule.condition})`);
                        console.log(`[DEBUG] Responses object:`, responses);
                        console.log(`[DEBUG] Other question ID: ${otherQuestion.id}, Response:`, otherQuestionResponse);
                        
                        // Enhanced condition evaluation
                        let conditionMet = false;
                        
                        // Direct string comparison
                        if (otherQuestionAnswer === rule.condition) {
                            conditionMet = true;
                            console.log(`[SUCCESS] Direct string match: "${otherQuestionAnswer}" === "${rule.condition}"`);
                        }
                        // Case-insensitive comparison
                        else if (otherQuestionAnswer && rule.condition && 
                                otherQuestionAnswer.toString().toLowerCase() === rule.condition.toString().toLowerCase()) {
                            conditionMet = true;
                            console.log(`[SUCCESS] Case-insensitive match: "${otherQuestionAnswer}" === "${rule.condition}"`);
                        }
                        // Check if response contains the condition (for partial matches)
                        else if (otherQuestionAnswer && rule.condition && 
                                otherQuestionAnswer.toString().toLowerCase().includes(rule.condition.toString().toLowerCase())) {
                            conditionMet = true;
                            console.log(`[SUCCESS] Contains match: "${otherQuestionAnswer}" contains "${rule.condition}"`);
                        }
                        // For cascading dropdowns, check if the category matches
                        else if (otherQuestion.question_type === 'cascading_dropdown' && otherQuestionResponse && 
                                otherQuestionResponse.category === rule.condition) {
                            conditionMet = true;
                            console.log(`[SUCCESS] Cascading category match: "${otherQuestionResponse.category}" === "${rule.condition}"`);
                        }
                        
                        if (conditionMet) {
                            console.log(`[SUCCESS] CONDITION MET: "${otherQuestionAnswer}" matches "${rule.condition}"`);
                            if (rule.action === 'show_question') {
                                shouldShow = true;
                                console.log(`[ACTION] Setting shouldShow = true for question ${question.id}`);
                            } else if (rule.action === 'hide_question') {
                                shouldShow = false;
                                console.log(`[ACTION] Setting shouldShow = false for question ${question.id}`);
                            }
                            // Don't break here - continue processing other rules that might also target this question
                        } else {
                            console.log(`[ERROR] CONDITION NOT MET: "${otherQuestionAnswer}" does not match "${rule.condition}"`);
                        }
                    }
                }
            }
        }
        
        // If this question has rules controlling it, return the result from rule processing
        if (hasRules) {
            // shouldShow was already set correctly in the main loop above
            console.log(`Question ${question.id} has rules. Final shouldShow: ${shouldShow}`);
            return shouldShow;
        }
        
        // No rules affecting this question, use default view
        console.log(`Question ${question.id} has no rules, using default view: ${question.default_view}`);
        return question.default_view === 'show';
    }
    
    function evaluateCondition(condition) {
        if (!condition) return false;
        
        const { question_id, operator, value } = condition;
        const response = responses[question_id];
        
        if (!response) return false;
        
        switch (operator) {
            case 'equals':
                return response == value;
            case 'not_equals':
                return response != value;
            case 'contains':
                return String(response).toLowerCase().includes(String(value).toLowerCase());
            case 'not_contains':
                return !String(response).toLowerCase().includes(String(value).toLowerCase());
            case 'is_empty':
                return !response || response === '';
            case 'is_not_empty':
                return response && response !== '';
            case 'greater_than':
                return parseFloat(response) > parseFloat(value);
            case 'less_than':
                return parseFloat(response) < parseFloat(value);
            default:
                return false;
        }
    }
    
    function reEvaluateQuestionVisibility() {
        console.log('[PROCESS] === reEvaluateQuestionVisibility called ===');
        const currentStep = steps[currentStepIndex];
        if (!currentStep || !currentStep.questions) return;
        
        console.log(`[PROCESS] Checking visibility for ${currentStep.questions.length} questions`);
        currentStep.questions.forEach(question => {
            console.log(`[PROCESS] Re-evaluating question ${question.id}: ${question.question_text}`);
            const questionElement = document.querySelector(`[data-question-id="${question.id}"]`);
            if (!questionElement) {
                console.log(`[ERROR] Question element not found for ${question.id}`);
                return;
            }
            
            const shouldShow = shouldShowQuestion(question);
            console.log(`[PROCESS] Question ${question.id} should show: ${shouldShow}`);
            questionElement.style.display = shouldShow ? 'block' : 'none';
            console.log(`[PROCESS] Question ${question.id} display set to: ${shouldShow ? 'block' : 'none'}`);
        });
        console.log('[PROCESS] === reEvaluateQuestionVisibility completed ===');
    }
    
    function validateCurrentStep() {
        const errors = [];
        const currentStep = steps[currentStepIndex];
        
        if (!currentStep || !currentStep.questions) {
            return errors;
        }
        
        // Check each question in the current step
        currentStep.questions.forEach(question => {
            // Skip if question is not visible (due to conditional logic)
            if (!shouldShowQuestion(question)) {
                return;
            }
            
            const questionId = question.id.toString();
            const responseValue = responses[questionId];
            
            // Check if required question is answered
            if (question.is_required) {
                if (question.question_type === 'cascading_dropdown') {
                    // For cascading dropdowns, check the response object structure
                    const response = responses[questionId];
                    
                    if (!response || typeof response !== 'object') {
                        errors.push({
                            question_id: questionId,
                            question_text: question.question_text,
                            error: 'Please select a category',
                            field_type: 'category'
                        });
                        return;
                    }
                    
                    if (!response.category || response.category === '') {
                        errors.push({
                            question_id: questionId,
                            question_text: question.question_text,
                            error: 'Please select a category',
                            field_type: 'category'
                        });
                        return;
                    }
                    
                    // Only require subcategory if the selected category has subcategories available
                    const cascadingConfig = question.cascading_config || {};
                    const categories = cascadingConfig.categories || [];
                    const selectedCategory = categories.find(cat => cat.name === response.category);
                    
                    if (selectedCategory && selectedCategory.subcategories && selectedCategory.subcategories.length > 0) {
                        if (!response.subcategory || response.subcategory === '') {
                            errors.push({
                                question_id: questionId,
                                question_text: question.question_text,
                                error: 'Please select a subcategory',
                                field_type: 'subcategory'
                            });
                            return;
                        }
                    }
                } else {
                    // For other question types, check the main response value
                    const isAnswered = responseValue && responseValue !== '' && !(Array.isArray(responseValue) && responseValue.length === 0);
                    if (!isAnswered) {
                        errors.push({
                            question_id: questionId,
                            question_text: question.question_text,
                            error: 'This field is required'
                        });
                        return;
                    }
                }
            }
            
            // Skip validation if not required and empty
            if (!responseValue || responseValue === '' || (Array.isArray(responseValue) && responseValue.length === 0)) {
                return;
            }
            
            // Type-specific validation
            if (question.question_type === 'email') {
                const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                if (!emailPattern.test(responseValue)) {
                    errors.push({
                        question_id: questionId,
                        question_text: question.question_text,
                        error: 'Please enter a valid email address'
                    });
                }
            } else if (question.question_type === 'phone') {
                const phonePattern = /^[\+]?[1-9][\d]{0,15}$/;
                const cleanPhone = responseValue.replace(/[\s\-\(\)]/g, '');
                if (!phonePattern.test(cleanPhone)) {
                    errors.push({
                        question_id: questionId,
                        question_text: question.question_text,
                        error: 'Please enter a valid phone number'
                    });
                }
            } else if (question.question_type === 'url') {
                const urlPattern = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
                if (!urlPattern.test(responseValue)) {
                    errors.push({
                        question_id: questionId,
                        question_text: question.question_text,
                        error: 'Please enter a valid URL'
                    });
                }
            }
        });
        
        return errors;
    }
    
    function showFieldValidationError(questionId, errorMessage, fieldType = null) {
        const questionElement = document.querySelector(`[data-question-id="${questionId}"]`);
        if (!questionElement) {
            console.error('Question element not found for ID:', questionId);
            return;
        }
        
        let inputField = null;
        
        if (fieldType === 'category') {
            // Find the category field
            inputField = questionElement.querySelector(`#category_${questionId}`);
        } else if (fieldType === 'subcategory') {
            // Find the subcategory field
            inputField = questionElement.querySelector(`#subcategory_${questionId}`);
        } else {
            // For other question types, find the first input/select/textarea
            inputField = questionElement.querySelector('input, textarea, select');
        }
        
        if (!inputField) return;
        
        // Add error styling to the input
        inputField.classList.add('is-invalid');
        
        // Create or update error message
        let errorDiv = questionElement.querySelector('.validation-error-message');
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.className = 'validation-error-message invalid-feedback';
            errorDiv.style.display = 'block';
            errorDiv.style.color = '#dc3545';
            errorDiv.style.fontSize = '0.875em';
            errorDiv.style.marginTop = '0.25rem';
            
            // Insert after the input field
            inputField.parentNode.insertBefore(errorDiv, inputField.nextSibling);
        }
        
        errorDiv.textContent = errorMessage;
    }
    
    function clearValidationMessages() {
        // Remove error styling from all inputs
        const invalidInputs = document.querySelectorAll('.is-invalid');
        invalidInputs.forEach(input => {
            input.classList.remove('is-invalid');
        });
        
        // Remove all validation error messages
        const errorMessages = document.querySelectorAll('.validation-error-message');
        errorMessages.forEach(message => {
            message.remove();
        });
    }
    
    function showStepMessage(message) {
        // Create a modal or alert to show the step completion message
        // For now, we'll use a styled alert, but you can replace this with a modal
        
        // Create a custom message container
        const messageContainer = document.createElement('div');
        messageContainer.className = 'step-message-container';
        messageContainer.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 500px;
            text-align: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        messageContainer.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 15px;">SUCCESS</div>
            <h4 style="margin: 0 0 15px 0; font-weight: 600;">Step Completed!</h4>
            <p style="margin: 0 0 20px 0; line-height: 1.5;">${message}</p>
            <button onclick="this.parentElement.remove()" style="
                background: rgba(255,255,255,0.2);
                border: 2px solid rgba(255,255,255,0.3);
                color: white;
                padding: 10px 25px;
                border-radius: 25px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                Continue
            </button>
        `;
        
        // Add backdrop
        const backdrop = document.createElement('div');
        backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
        `;
        
        // Add to page
        document.body.appendChild(backdrop);
        document.body.appendChild(messageContainer);
        
        // Auto-remove after 5 seconds if user doesn't click
        setTimeout(() => {
            if (messageContainer.parentElement) {
                backdrop.remove();
                messageContainer.remove();
            }
        }, 5000);
        
        // Remove backdrop when message is closed
        messageContainer.addEventListener('click', function(e) {
            if (e.target === this || e.target.tagName === 'BUTTON') {
                backdrop.remove();
                messageContainer.remove();
            }
        });
    }
    
    function checkBranchingLogic(question) {
        if (!question.branching_logic || !question.branching_logic.enabled) return;
        
        const response = getQuestionResponse(question);
        if (!response) return;
        
        // Find matching rule
        const rules = question.branching_logic.rules || [];
        for (const rule of rules) {
            if (matchesCondition(response, rule.condition)) {
                // Navigate based on target type
                handleBranchingNavigation(rule);
                return;
            }
        }
    }
    
    function handleBranchingNavigation(rule) {
        if (rule.message) {
            alert(rule.message);
        }
        
        switch (rule.target_type) {
            case 'specific_question_local':
                // Go to specific question in current step
                navigateToLocalQuestion(rule.target_question_id);
                break;
                
            case 'specific_step':
                // Go to specific step
                navigateToStep(rule.target_step);
                break;
                
            case 'specific_step_question':
                // Go to specific question in specific step
                navigateToSpecificQuestion(rule.target_step, rule.target_question_id);
                break;
        }
    }
    
    function goToNextQuestion() {
        if (steps.length > 0) {
            // In step blocks system, this would go to next question in current step
            // For now, just go to next step
            goToNextStep();
        } else {
            // Old question system
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                renderCurrentQuestion();
                updateProgress();
            }
        }
    }
    
    function goToNextStep() {
        if (steps.length > 0) {
            const currentStep = steps[currentStepIndex];
            
            // Show completion message if it exists
            if (currentStep && currentStep.completion_message) {
                showStepMessage(currentStep.completion_message);
            }
            
            currentStepIndex++;
            if (currentStepIndex < steps.length) {
                renderCurrentStep();
                updateProgress();
            }
        }
    }
    
    function navigateToLocalQuestion(questionId) {
        // For local questions, we stay in the current step
        // This is a placeholder for future question-level navigation within steps
        // For now, we'll just show a message or continue to next step
        console.log('Navigate to local question:', questionId);
        // TODO: Implement question-level navigation within current step
    }
    
    function navigateToSpecificQuestion(stepId, questionId) {
        // Find the step
        const targetStep = steps.find(step => step.id === stepId);
        if (!targetStep) return;
        
        // Find the question within the step
        const targetQuestion = targetStep.questions.find(q => q.id === questionId);
        if (!targetQuestion) return;
        
        // Navigate to the step
        currentStepIndex = steps.indexOf(targetStep);
        
        // Show completion message if it exists
        if (targetStep.completion_message) {
            showStepMessage(targetStep.completion_message);
        }
        
        renderCurrentStep();
        updateProgress();
        
        // TODO: Implement question-level navigation within step
        // This would require more complex UI to show specific questions
    }
    
    function matchesCondition(response, condition) {
        if (Array.isArray(response)) {
            // For checkbox responses
            return response.includes(condition);
        } else {
            // For other response types
            return response.toString().toLowerCase() === condition.toLowerCase();
        }
    }
    
    function navigateToStep(targetStepIndex, message) {
        // Find the step with the matching index
        const targetStep = steps.find(step => step.step_order === targetStepIndex);
        if (!targetStep) return;
        
        // Show message if provided
        if (message) {
            alert(message);
        }
        
        // Navigate to the target step
        currentStepIndex = steps.indexOf(targetStep);
        if (currentStepIndex >= 0) {
            // Show completion message if it exists
            if (targetStep.completion_message) {
                showStepMessage(targetStep.completion_message);
            }
            
            renderCurrentStep();
            updateProgress();
        }
    }
    
    function updateProgress() {
        let progress, current, total;
        
        if (steps.length > 0) {
            // Step blocks system
            progress = ((currentStepIndex + 1) / steps.length) * 100;
            current = currentStepIndex + 1;
            total = steps.length;
        } else {
            // Old question system
            progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            current = currentQuestionIndex + 1;
            total = questions.length;
        }
        
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${current} of ${total}`;
    }
    
    function updateNavigation() {
        let isFirst, isLast;
        
        if (steps.length > 0) {
            // Step blocks system
            isFirst = currentStepIndex === 0;
            isLast = currentStepIndex >= steps.length - 1;
        } else {
            // Old question system
            isFirst = currentQuestionIndex === 0;
            isLast = currentQuestionIndex >= questions.length - 1;
        }
        
        prevBtn.style.display = !isFirst ? 'block' : 'none';
        
        if (isLast) {
            nextBtn.style.display = 'none';
            submitBtn.style.display = 'inline-block';
        } else {
            nextBtn.style.display = 'inline-block';
            submitBtn.style.display = 'none';
        }
        
        saveBtn.style.display = 'inline-block';
    }
    
    // Event listeners
    prevBtn.addEventListener('click', function() {
        saveCurrentResponse();
        
        if (steps.length > 0) {
            // Step blocks system
            currentStepIndex--;
            const newStep = steps[currentStepIndex];
            
            // Show completion message if it exists (for going back to a completed step)
            if (newStep && newStep.completion_message) {
                showStepMessage(newStep.completion_message);
            }
            
            renderCurrentStep();
        } else {
            // Old question system
            currentQuestionIndex--;
            renderCurrentQuestion();
        }
        
        updateProgress();
    });
    
    nextBtn.addEventListener('click', function(e) {
        // CRITICAL: Block if uploads are in progress
        const uploadingElements = document.querySelectorAll('[data-uploading="true"]');
        if (uploadingElements.length > 0) {
            e.preventDefault();
            e.stopPropagation();
            alert('‚è≥ Please wait for file uploads to complete before proceeding.');
            return false;
        }
        
        saveCurrentResponse();
        
        if (steps.length > 0) {
            // Step blocks system
            const currentStep = steps[currentStepIndex];
            
            // Validate current step before moving to next
            const validationErrors = validateCurrentStep();
            if (validationErrors.length > 0) {
                // Clear previous error messages
                clearValidationMessages();
                
                // Show validation errors under each field
                validationErrors.forEach(error => {
                    showFieldValidationError(error.question_id, error.error, error.field_type);
                });
                
                // Scroll to first error question
                const firstError = validationErrors[0];
                const errorElement = document.querySelector(`[data-question-id="${firstError.question_id}"]`);
                if (errorElement) {
                    errorElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return; // Don't proceed to next step
            }
            
            // Show completion message if it exists
            if (currentStep && currentStep.completion_message) {
                showStepMessage(currentStep.completion_message);
            }
            
            currentStepIndex++;
            renderCurrentStep();
        } else {
            // Old question system
            currentQuestionIndex++;
            renderCurrentQuestion();
        }
        
        updateProgress();
    });
    
    saveBtn.addEventListener('click', function() {
        saveCurrentResponse();
        saveProgress();
    });
    
    document.getElementById('chatbotForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // CRITICAL: Block if uploads are in progress
        const uploadingElements = document.querySelectorAll('[data-uploading="true"]');
        if (uploadingElements.length > 0) {
            e.stopPropagation();
            alert('‚è≥ Please wait for file uploads to complete before submitting.');
            return false;
        }
        
        saveCurrentResponse();
        submitForm();
    });
    
    function saveProgress() {
        showLoading();
        
        // Get CSRF token
        const csrfToken = document.querySelector('meta[name=csrf-token]')?.getAttribute('content');
        
        fetch(`/chatbot/${flowId}/submit`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken || ''
            },
            body: JSON.stringify({
                responses: responses,
                completed: false,
                csrf_token: csrfToken
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show success message briefly
                const btn = saveBtn;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check me-2"></i>Saved!';
                btn.classList.remove('btn-outline-primary');
                btn.classList.add('btn-success');
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-outline-primary');
                }, 2000);
            } else {
                alert('Error saving progress: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while saving progress.');
        })
        .finally(() => {
            hideLoading();
        });
    }
    
    function submitForm() {
        showLoading();
        
        // SIMPLIFIED APPROACH: Only check for actual loading indicators (exclude loading overlay)
        const allSpinners = document.querySelectorAll('.fa-spinner');
        const loadingOverlaySpinner = document.querySelector('#loadingOverlay .fa-spinner');
        const actualSpinners = Array.from(allSpinners).filter(spinner => spinner !== loadingOverlaySpinner);
        const uploading = document.querySelectorAll('.uploading');
        const dataUploading = document.querySelectorAll('[data-uploading="true"]');
        
        const loadingIndicators = [...actualSpinners, ...uploading, ...dataUploading];
        const pendingUploads = loadingIndicators.length;
        
        console.log(`DEBUG: Found ${pendingUploads} pending uploads (loading indicators only)`);
        console.log(`DEBUG: Loading indicators found:`, loadingIndicators);
        
        // Debug: Check each type of indicator
        console.log(`DEBUG: All spinners: ${allSpinners.length}, Actual spinners: ${actualSpinners.length}, Uploading: ${uploading.length}, Data-uploading: ${dataUploading.length}`);
        
        // Only send pending uploads if there are actual loading indicators
        const shouldSendPendingUploads = pendingUploads > 0;
        
        // Get CSRF token
        const csrfToken = document.querySelector('meta[name=csrf-token]')?.getAttribute('content');
        
        fetch(`/chatbot/${flowId}/submit`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken || ''
            },
            body: JSON.stringify({
                responses: responses,
                completed: true,
                ...(shouldSendPendingUploads && { pending_uploads: pendingUploads }),  // Only send if there are actual uploads
                csrf_token: csrfToken
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.storage_status === 'stored') {
                // Only redirect if item was successfully created
                window.location.href = `/chatbot/${flowId}/complete`;
            } else {
                // Handle item creation failures
                if (data.storage_status === 'failed') {
                    let errorMessage = 'Item Creation Failed\n\n';
                    errorMessage += data.message || data.error || 'Failed to create item due to data validation errors.\n\n';
                    errorMessage += 'Possible issues:\n';
                    errorMessage += '- Data type mismatch (e.g., text in a number field)\n';
                    errorMessage += '- Missing required fields\n';
                    errorMessage += '- Invalid data format\n\n';
                    errorMessage += 'Please check your responses and try again.';
                    alert(errorMessage);
                    
                    // Re-enable submit button
                    const submitBtn = document.getElementById('submitBtn');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-check me-2"></i>Complete';
                    }
                    return;
                }
                
                // Handle validation errors
                if (data.errors && data.errors.length > 0) {
                    let errorMessage = 'Please fix the following errors:\n\n';
                    data.errors.forEach(error => {
                        errorMessage += `- ${error.question_text}: ${error.error}\n`;
                    });
                    alert(errorMessage);
                    
                    // Scroll to first error question
                    const firstError = data.errors[0];
                    const errorElement = document.querySelector(`[data-question-id="${firstError.question_id}"]`);
                    if (errorElement) {
                        errorElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        errorElement.style.border = '2px solid #dc3545';
                        setTimeout(() => {
                            errorElement.style.border = '';
                        }, 3000);
                    }
                } else {
                    alert('Error submitting form: ' + (data.message || data.error || 'Unknown error'));
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while submitting the form.');
        })
        .finally(() => {
            hideLoading();
        });
    }
    
    // Setup media upload type toggles
    function setupMediaUploadToggles() {
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('media-type-checkbox')) {
                const mediaType = e.target.value;
                const questionId = e.target.id.split('_').pop();
                const uploadBox = document.getElementById(`upload-box-${mediaType}-${questionId}`);
                
                if (uploadBox) {
                    if (e.target.checked) {
                        uploadBox.style.display = 'block';
                    } else {
                        uploadBox.style.display = 'none';
                    }
                }
            }
        });
    }
    
    // Setup file upload handling
    function setupFileUploadHandling() {
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('media-file-input')) {
                const fileType = e.target.dataset.fileType;
                const questionId = e.target.dataset.questionId;
                handleFileUpload(e.target, fileType, questionId);
            }
        });
        
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('media-url-input')) {
                const fileType = e.target.dataset.fileType;
                const questionId = e.target.dataset.questionId;
                handleUrlInput(e.target, fileType, questionId);
            }
        });
    }
    
    function handleFileUpload(fileInput, fileType, questionId) {
        const files = Array.from(fileInput.files);
        const previewArea = document.getElementById(`media-preview-${questionId}`);
        
        if (!previewArea) return;
        
        // Clear existing preview
        previewArea.innerHTML = '';
        
        if (files.length === 0) {
            previewArea.innerHTML = '<p class="text-muted">No files selected</p>';
            return;
        }
        
        // Show loading state and mark as uploading
        previewArea.innerHTML = '<p class="text-muted"><i class="fas fa-spinner fa-spin"></i> Uploading files...</p>';
        previewArea.setAttribute('data-uploading', 'true');
        
        // Mark as uploading
        console.log(`DEBUG: Started upload of ${files.length} files`);
        
        // Update button states immediately
        if (typeof updateNavigationButtons === 'function') {
            updateNavigationButtons();
        }
        
        // Upload each file to the server
        const uploadPromises = files.map((file, index) => {
            return uploadFileToServer(file, fileType, questionId, index);
        });
        
        // Wait for all uploads to complete
        Promise.all(uploadPromises)
            .then((uploadResults) => {
                // Clear loading state and mark as not uploading
                previewArea.innerHTML = '';
                previewArea.removeAttribute('data-uploading');
                
                // Mark as completed
                console.log(`DEBUG: Completed upload of ${files.length} files`);
                
                // Update button states immediately after upload completes
                if (typeof updateNavigationButtons === 'function') {
                    updateNavigationButtons();
                }
                
                // Create preview for each successfully uploaded file
                uploadResults.forEach((result, index) => {
                    if (result.success) {
                        const filePreview = createFilePreview(result.file, fileType, questionId, index, result.fileInfo);
                        previewArea.appendChild(filePreview);
                    } else {
                        // Show error for failed upload
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'alert alert-danger';
                        errorDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Failed to upload ${result.file.name}: ${result.error}`;
                        previewArea.appendChild(errorDiv);
                    }
                });
            })
            .catch((error) => {
                console.error('Upload error:', error);
                previewArea.innerHTML = '<p class="text-danger"><i class="fas fa-exclamation-triangle"></i> Error uploading files</p>';
                previewArea.removeAttribute('data-uploading');
                
                // Mark as completed with error
                console.log(`DEBUG: Error in upload of ${files.length} files`);
                
                // Update button states immediately after error
                if (typeof updateNavigationButtons === 'function') {
                    updateNavigationButtons();
                }
            });
    }
    
    function uploadFileToServer(file, fileType, questionId, index) {
        return new Promise((resolve) => {
            // Mobile device detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Mobile-specific file validation
            const maxSize = isMobile ? 8 * 1024 * 1024 : 10 * 1024 * 1024; // 8MB mobile, 10MB desktop
            
            if (file.size > maxSize) {
                const maxSizeMB = isMobile ? 8 : 10;
                resolve({
                    success: false,
                    file: file,
                    error: `File too large for ${isMobile ? 'mobile' : 'desktop'}. Maximum size: ${maxSizeMB}MB. Please compress your photo or use a smaller image.`
                });
                return;
            }
            
            // Check for HEIC/HEIF format (iPhone default)
            const fileName = file.name.toLowerCase();
            if (fileName.endsWith('.heic') || fileName.endsWith('.heif')) {
                resolve({
                    success: false,
                    file: file,
                    error: 'HEIC/HEIF format not supported. Please convert to JPG or PNG on your device. iPhone users: Settings ‚Üí Camera ‚Üí Formats ‚Üí Most Compatible'
                });
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('question_id', questionId);
            formData.append('category', fileType);
            
            // Get CSRF token from meta tag
            const csrfToken = document.querySelector('meta[name=csrf-token]')?.getAttribute('content');
            if (csrfToken) {
                formData.append('csrf_token', csrfToken);
            }
            
            // Mobile-specific timeout handling
            const timeoutDuration = isMobile ? 45000 : 120000; // 45s mobile, 2min desktop
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
            }, timeoutDuration);
            
            fetch(`/chatbot/${flowId}/upload`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': csrfToken || ''
                },
                signal: controller.signal
            })
            .then(response => {
                clearTimeout(timeoutId);
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    console.log('File uploaded successfully:', data.file_info);
                    resolve({
                        success: true,
                        file: file,
                        fileInfo: data.file_info
                    });
                } else {
                    console.error('Upload failed:', data.error);
                    resolve({
                        success: false,
                        file: file,
                        error: data.error
                    });
                }
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error('Upload error:', error);
                
                let errorMessage = error.message;
                if (error.name === 'AbortError') {
                    errorMessage = isMobile ? 
                        'Upload timeout. Mobile uploads may take longer. Please try again with a smaller file.' :
                        'Upload timeout. Please try again.';
                }
                
                resolve({
                    success: false,
                    file: file,
                    error: errorMessage
                });
            });
        });
    }
    
    function handleUrlInput(urlInput, fileType, questionId) {
        const urls = urlInput.value.trim().split('\n').filter(url => url.trim());
        const previewArea = document.getElementById(`media-preview-${questionId}`);
        
        if (!previewArea) return;
        
        // Get existing file previews
        const existingFilePreviews = previewArea.querySelectorAll('.file-preview');
        
        // Clear URL previews
        const existingUrlPreviews = previewArea.querySelectorAll('.url-preview');
        existingUrlPreviews.forEach(preview => preview.remove());
        
        if (urls.length === 0 && existingFilePreviews.length === 0) {
            previewArea.innerHTML = '<p class="text-muted">No files or URLs provided</p>';
            return;
        }
        
        // Create preview for each URL
        urls.forEach((url, index) => {
            const urlPreview = createUrlPreview(url, fileType, questionId, index);
            previewArea.appendChild(urlPreview);
        });
    }
    
    function createFilePreview(file, fileType, questionId, index, fileInfo = null) {
        const fileSize = formatFileSize(file.size);
        const fileIcon = getFileIcon(file.type, fileType);
        
        const preview = document.createElement('div');
        preview.className = 'file-preview d-flex align-items-center p-2 mb-2 bg-light rounded';
        
        // Store the full fileInfo as a data attribute so we can retrieve it later
        if (fileInfo) {
            preview.setAttribute('data-file-info', JSON.stringify(fileInfo));
        }
        
        // Show upload status
        const statusIcon = fileInfo ? '<i class="fas fa-check-circle text-success me-1"></i>' : '<i class="fas fa-upload text-warning me-1"></i>';
        const statusText = fileInfo ? 'Uploaded' : 'Pending';
        
        preview.innerHTML = `
            <i class="${fileIcon} me-2 text-primary"></i>
            <div class="flex-grow-1">
                <div class="fw-bold">${file.name} ${statusIcon}</div>
                <small class="text-muted">${fileSize} - ${file.type} - ${statusText}</small>
                ${fileInfo ? `<small class="text-success d-block">Saved as: ${fileInfo.saved_name}</small>` : ''}
            </div>
            <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeFilePreview(this, '${fileType}', '${questionId}')">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        return preview;
    }
    
    function createUrlPreview(url, fileType, questionId, index) {
        const urlIcon = getFileIcon('url', fileType);
        
        const preview = document.createElement('div');
        preview.className = 'url-preview d-flex align-items-center p-2 mb-2 bg-light rounded';
        preview.innerHTML = `
            <i class="${urlIcon} me-2 text-success"></i>
            <div class="flex-grow-1">
                <div class="fw-bold">External URL</div>
                <small class="text-muted">${url}</small>
            </div>
            <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeUrlPreview(this, '${fileType}', '${questionId}')">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        return preview;
    }
    
    function getFileIcon(mimeType, fileType) {
        const fileTypeIcons = {
            'images': 'fas fa-image',
            'videos': 'fas fa-video',
            'audio': 'fas fa-music',
            'files_documents': 'fas fa-file-alt'
        };
        
        if (mimeType === 'url') {
            return 'fas fa-university';
        }
        
        if (mimeType.startsWith('image/')) return 'fas fa-image';
        if (mimeType.startsWith('video/')) return 'fas fa-video';
        if (mimeType.startsWith('audio/')) return 'fas fa-music';
        if (mimeType === 'application/pdf') return 'fas fa-file-pdf';
        if (mimeType.includes('word') || mimeType.includes('document')) return 'fas fa-file-word';
        if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'fas fa-file-excel';
        if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'fas fa-file-powerpoint';
        if (mimeType.includes('zip') || mimeType.includes('archive')) return 'fas fa-file-archive';
        
        return fileTypeIcons[fileType] || 'fas fa-file';
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    function removeFilePreview(button, fileType, questionId) {
        const preview = button.closest('.file-preview');
        preview.remove();
        
        // Clear the file input
        const fileInput = document.querySelector(`[name="question_${questionId}_files"]`);
        if (fileInput) {
            fileInput.value = '';
        }
        
        // Update preview area if empty
        const previewArea = document.getElementById(`media-preview-${questionId}`);
        if (previewArea && previewArea.children.length === 0) {
            previewArea.innerHTML = '<p class="text-muted">No files selected</p>';
        }
    }
    
    function removeUrlPreview(button, fileType, questionId) {
        const preview = button.closest('.url-preview');
        const urlText = preview.querySelector('small').textContent;
        
        // Remove from textarea
        const urlInput = document.querySelector(`[name="question_${questionId}_urls"]`);
        if (urlInput) {
            const urls = urlInput.value.split('\n').filter(url => url.trim() !== urlText.trim());
            urlInput.value = urls.join('\n');
        }
        
        preview.remove();
        
        // Update preview area if empty
        const previewArea = document.getElementById(`media-preview-${questionId}`);
        if (previewArea && previewArea.children.length === 0) {
            previewArea.innerHTML = '<p class="text-muted">No files or URLs provided</p>';
        }
    }
    
    // ===== BUTTON STATE MANAGEMENT =====
    // Function to check if any uploads are in progress
    function hasActiveUploads() {
        const uploadingElements = document.querySelectorAll('[data-uploading="true"]');
        return uploadingElements.length > 0;
    }
    
    // Function to validate required fields in current step
    function hasUnfilledRequiredFields() {
        const currentStep = steps[currentStepIndex];
        if (!currentStep || !currentStep.questions) return false;
        
        for (const question of currentStep.questions) {
            // Skip if question is not visible
            const questionElement = document.getElementById(`question-${question.id}`);
            if (!questionElement || questionElement.style.display === 'none') {
                continue;
            }
            
            // Check if question is required
            if (question.is_required) {
                const response = getQuestionResponse(question);
                
                // Check if response is empty/null
                if (!response) {
                    return true; // Has unfilled required field
                }
                
                // Additional checks for different field types
                if (typeof response === 'string' && response.trim() === '') {
                    return true;
                }
                if (Array.isArray(response) && response.length === 0) {
                    return true;
                }
                if (typeof response === 'object') {
                    // For file uploads
                    if (response.files && response.files.length === 0 && response.urls && response.urls.length === 0) {
                        return true;
                    }
                    // For other object responses (like cascading dropdowns)
                    if (Object.keys(response).length === 0) {
                        return true;
                    }
                }
            }
        }
        
        return false; // All required fields are filled
    }
    
    // Function to update button states
    function updateNavigationButtons() {
        const nextBtn = document.getElementById('nextBtn');
        const submitBtn = document.getElementById('submitBtn');
        
        const uploadsInProgress = hasActiveUploads();
        const requiredFieldsMissing = hasUnfilledRequiredFields();
        const shouldDisable = uploadsInProgress || requiredFieldsMissing;
        
        // Debug logging
        if (uploadsInProgress) {
            console.log('üî¥ UPLOADS IN PROGRESS - Buttons disabled');
        }
        
        // Update Next button
        if (nextBtn && nextBtn.style.display !== 'none') {
            if (shouldDisable) {
                nextBtn.disabled = true;
                nextBtn.classList.remove('btn-primary');
                nextBtn.classList.add('btn-secondary');
                
                // Update button text to show why it's disabled
                const icon = nextBtn.querySelector('i');
                if (uploadsInProgress) {
                    nextBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Uploading...';
                } else if (requiredFieldsMissing) {
                    nextBtn.innerHTML = 'Complete Required Fields <i class="fas fa-arrow-right ms-2"></i>';
                }
            } else {
                nextBtn.disabled = false;
                nextBtn.classList.remove('btn-secondary');
                nextBtn.classList.add('btn-primary');
                nextBtn.innerHTML = 'Next <i class="fas fa-arrow-right ms-2"></i>';
            }
        }
        
        // Update Submit button (Complete button)
        if (submitBtn && submitBtn.style.display !== 'none') {
            if (shouldDisable) {
                submitBtn.disabled = true;
                submitBtn.classList.remove('btn-success');
                submitBtn.classList.add('btn-secondary');
                
                // Update button text to show why it's disabled
                if (uploadsInProgress) {
                    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Uploading...';
                } else if (requiredFieldsMissing) {
                    submitBtn.innerHTML = '<i class="fas fa-exclamation-circle me-2"></i>Complete Required Fields';
                }
            } else {
                submitBtn.disabled = false;
                submitBtn.classList.remove('btn-secondary');
                submitBtn.classList.add('btn-success');
                submitBtn.innerHTML = '<i class="fas fa-check me-2"></i>Complete';
            }
        }
    }
    
    // Call updateNavigationButtons whenever there's a change
    // Set up observers for form changes
    const chatbotForm = document.getElementById('chatbotForm');
    if (chatbotForm) {
        // Update on any input change
        chatbotForm.addEventListener('input', function() {
            updateNavigationButtons();
        });
        
        // Update on any change event (for selects, checkboxes, etc.)
        chatbotForm.addEventListener('change', function() {
            updateNavigationButtons();
        });
    }
    
    // Set up a periodic check for upload status (every 200ms for faster response)
    setInterval(function() {
        updateNavigationButtons();
    }, 200);
    
    // Initial button state update
    updateNavigationButtons();
    
    // Also update when page becomes visible again (user switches back to tab)
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            updateNavigationButtons();
        }
    });
    
    // Initialize media upload toggles and file handling
    setupMediaUploadToggles();
    setupFileUploadHandling();
});
</script>
{% endblock %}
